// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: search.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Search.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
#import "Definitions.pbobjc.h"
#import "Groups.pbobjc.h"
#import "Peers.pbobjc.h"
#import "Messaging.pbobjc.h"
#import "Users.pbobjc.h"
#import "Miscellaneous.pbobjc.h"
#import "scalapb/Scalapb.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBBoolValue);
GPBObjCClassDeclaration(GPBBytesValue);
GPBObjCClassDeclaration(GPBInt32Value);
GPBObjCClassDeclaration(GPBInt64Value);
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(Group);
GPBObjCClassDeclaration(GroupOutPeer);
GPBObjCClassDeclaration(MessageContent);
GPBObjCClassDeclaration(MessageSearchItem);
GPBObjCClassDeclaration(MessageSearchResult);
GPBObjCClassDeclaration(OutPeer);
GPBObjCClassDeclaration(Peer);
GPBObjCClassDeclaration(PeerSearchResult);
GPBObjCClassDeclaration(SearchAndCondition);
GPBObjCClassDeclaration(SearchCondition);
GPBObjCClassDeclaration(SearchOrCondition);
GPBObjCClassDeclaration(SearchPeerCondition);
GPBObjCClassDeclaration(SearchPeerContentType);
GPBObjCClassDeclaration(SearchPeerTypeCondition);
GPBObjCClassDeclaration(SearchPieceText);
GPBObjCClassDeclaration(SearchPredicate);
GPBObjCClassDeclaration(SearchSenderIdConfition);
GPBObjCClassDeclaration(SimpleContactSearchCondition);
GPBObjCClassDeclaration(SimpleGroupSearchCondition);
GPBObjCClassDeclaration(SimpleMessageSearchCondition);
GPBObjCClassDeclaration(SimplePeerSearchCondition);
GPBObjCClassDeclaration(SimpleSearchCondition);
GPBObjCClassDeclaration(SimpleUserProfileSearchCondition);
GPBObjCClassDeclaration(UUIDValue);
GPBObjCClassDeclaration(User);
GPBObjCClassDeclaration(UserMatch);
GPBObjCClassDeclaration(UserOutPeer);

#pragma mark - SearchRoot

@implementation SearchRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
    [registry addExtensions:[DefinitionsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - SearchRoot_FileDescriptor

static GPBFileDescriptor *SearchRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"dialog"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SearchPeerType

GPBEnumDescriptor *SearchPeerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchpeertypeUnknown\000SearchpeertypeGrou"
        "ps\000SearchpeertypeContacts\000Searchpeertype"
        "Public\000";
    static const int32_t values[] = {
        SearchPeerType_SearchpeertypeUnknown,
        SearchPeerType_SearchpeertypeGroups,
        SearchPeerType_SearchpeertypeContacts,
        SearchPeerType_SearchpeertypePublic,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchPeerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchPeerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchPeerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchPeerType_SearchpeertypeUnknown:
    case SearchPeerType_SearchpeertypeGroups:
    case SearchPeerType_SearchpeertypeContacts:
    case SearchPeerType_SearchpeertypePublic:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SearchContentType

GPBEnumDescriptor *SearchContentType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchcontenttypeUnknown\000Searchcontentty"
        "peAny\000SearchcontenttypeText\000Searchconten"
        "ttypeLinks\000SearchcontenttypeDocuments\000Se"
        "archcontenttypeMedia\000SearchcontenttypeAu"
        "dio\000";
    static const int32_t values[] = {
        SearchContentType_SearchcontenttypeUnknown,
        SearchContentType_SearchcontenttypeAny,
        SearchContentType_SearchcontenttypeText,
        SearchContentType_SearchcontenttypeLinks,
        SearchContentType_SearchcontenttypeDocuments,
        SearchContentType_SearchcontenttypeMedia,
        SearchContentType_SearchcontenttypeAudio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchContentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchContentType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchContentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchContentType_SearchcontenttypeUnknown:
    case SearchContentType_SearchcontenttypeAny:
    case SearchContentType_SearchcontenttypeText:
    case SearchContentType_SearchcontenttypeLinks:
    case SearchContentType_SearchcontenttypeDocuments:
    case SearchContentType_SearchcontenttypeMedia:
    case SearchContentType_SearchcontenttypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SearchDirection

GPBEnumDescriptor *SearchDirection_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SearchdirectionUnknown\000SearchdirectionFo"
        "rward\000SearchdirectionBackward\000";
    static const int32_t values[] = {
        SearchDirection_SearchdirectionUnknown,
        SearchDirection_SearchdirectionForward,
        SearchDirection_SearchdirectionBackward,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SearchDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SearchDirection_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SearchDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case SearchDirection_SearchdirectionUnknown:
    case SearchDirection_SearchdirectionForward:
    case SearchDirection_SearchdirectionBackward:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SimpleContactSearchCondition

@implementation SimpleContactSearchCondition

@dynamic text;

typedef struct SimpleContactSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} SimpleContactSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleContactSearchCondition_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleContactSearchCondition__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleContactSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleContactSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleMessageSearchCondition

@implementation SimpleMessageSearchCondition

@dynamic hasPeer, peer;
@dynamic text;
@dynamic type;
@dynamic searchDirection;
@dynamic hasDateFrom, dateFrom;

typedef struct SimpleMessageSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchContentType type;
  SearchDirection searchDirection;
  Peer *peer;
  NSString *text;
  GPBInt64Value *dateFrom;
} SimpleMessageSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = SimpleMessageSearchCondition_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleMessageSearchCondition_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SearchContentType_EnumDescriptor,
        .number = SimpleMessageSearchCondition_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "searchDirection",
        .dataTypeSpecific.enumDescFunc = SearchDirection_EnumDescriptor,
        .number = SimpleMessageSearchCondition_FieldNumber_SearchDirection,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, searchDirection),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dateFrom",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt64Value),
        .number = SimpleMessageSearchCondition_FieldNumber_DateFrom,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SimpleMessageSearchCondition__storage_, dateFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleMessageSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleMessageSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimpleMessageSearchCondition_Type_RawValue(SimpleMessageSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleMessageSearchCondition_Type_RawValue(SimpleMessageSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t SimpleMessageSearchCondition_SearchDirection_RawValue(SimpleMessageSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_SearchDirection];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimpleMessageSearchCondition_SearchDirection_RawValue(SimpleMessageSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimpleMessageSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimpleMessageSearchCondition_FieldNumber_SearchDirection];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimplePeerSearchCondition

@implementation SimplePeerSearchCondition

@dynamic peerType;
@dynamic hasText, text;

typedef struct SimplePeerSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchPeerType peerType;
  GPBStringValue *text;
} SimplePeerSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerType",
        .dataTypeSpecific.enumDescFunc = SearchPeerType_EnumDescriptor,
        .number = SimplePeerSearchCondition_FieldNumber_PeerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimplePeerSearchCondition__storage_, peerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = SimplePeerSearchCondition_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimplePeerSearchCondition__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimplePeerSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimplePeerSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SimplePeerSearchCondition_PeerType_RawValue(SimplePeerSearchCondition *message) {
  GPBDescriptor *descriptor = [SimplePeerSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimplePeerSearchCondition_FieldNumber_PeerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSimplePeerSearchCondition_PeerType_RawValue(SimplePeerSearchCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SimplePeerSearchCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SimplePeerSearchCondition_FieldNumber_PeerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SimpleUserProfileSearchCondition

@implementation SimpleUserProfileSearchCondition

@dynamic queryString;

typedef struct SimpleUserProfileSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *queryString;
} SimpleUserProfileSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryString",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleUserProfileSearchCondition_FieldNumber_QueryString,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleUserProfileSearchCondition__storage_, queryString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleUserProfileSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleUserProfileSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleGroupSearchCondition

@implementation SimpleGroupSearchCondition

@dynamic queryString;

typedef struct SimpleGroupSearchCondition__storage_ {
  uint32_t _has_storage_[1];
  NSString *queryString;
} SimpleGroupSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryString",
        .dataTypeSpecific.clazz = Nil,
        .number = SimpleGroupSearchCondition_FieldNumber_QueryString,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleGroupSearchCondition__storage_, queryString),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleGroupSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleGroupSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - criterion

@implementation criterion


typedef struct criterion__storage_ {
  uint32_t _has_storage_[1];
} criterion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[criterion class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(criterion__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleSearchCondition

@implementation SimpleSearchCondition

@dynamic criterionOneOfCase;
@dynamic contact;
@dynamic message;
@dynamic peer;
@dynamic userProfile;
@dynamic group;

typedef struct SimpleSearchCondition__storage_ {
  uint32_t _has_storage_[2];
  SimpleContactSearchCondition *contact;
  SimpleMessageSearchCondition *message;
  SimplePeerSearchCondition *peer;
  SimpleUserProfileSearchCondition *userProfile;
  SimpleGroupSearchCondition *group;
} SimpleSearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contact",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleContactSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Contact,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, contact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleMessageSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(SimplePeerSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Peer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userProfile",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleUserProfileSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_UserProfile,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, userProfile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "group",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleGroupSearchCondition),
        .number = SimpleSearchCondition_FieldNumber_Group,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SimpleSearchCondition__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleSearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleSearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "criterion",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SimpleSearchCondition_ClearCriterionOneOfCase(SimpleSearchCondition *message) {
  GPBDescriptor *descriptor = [SimpleSearchCondition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SearchCondition

@implementation SearchCondition

@dynamic bodyOneOfCase;
@dynamic searchPeerTypeCondition;
@dynamic searchPieceText;
@dynamic searchAndCondition;
@dynamic searchOrCondition;
@dynamic searchPeerCondition;
@dynamic searchPeerContentType;
@dynamic searchSenderIdConfition;

typedef struct SearchCondition__storage_ {
  uint32_t _has_storage_[2];
  SearchPeerTypeCondition *searchPeerTypeCondition;
  SearchPieceText *searchPieceText;
  SearchAndCondition *searchAndCondition;
  SearchOrCondition *searchOrCondition;
  SearchPeerCondition *searchPeerCondition;
  SearchPeerContentType *searchPeerContentType;
  SearchSenderIdConfition *searchSenderIdConfition;
} SearchCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchPeerTypeCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerTypeCondition),
        .number = SearchCondition_FieldNumber_SearchPeerTypeCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerTypeCondition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPieceText",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPieceText),
        .number = SearchCondition_FieldNumber_SearchPieceText,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPieceText),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchAndCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchAndCondition),
        .number = SearchCondition_FieldNumber_SearchAndCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchAndCondition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchOrCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchOrCondition),
        .number = SearchCondition_FieldNumber_SearchOrCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchOrCondition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPeerCondition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerCondition),
        .number = SearchCondition_FieldNumber_SearchPeerCondition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerCondition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchPeerContentType",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPeerContentType),
        .number = SearchCondition_FieldNumber_SearchPeerContentType,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchPeerContentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchSenderIdConfition",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchSenderIdConfition),
        .number = SearchCondition_FieldNumber_SearchSenderIdConfition,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SearchCondition__storage_, searchSenderIdConfition),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "body",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\027\000\002\017\000\003\022\000\004\021\000\005\023\000\006\025\000\007\027\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SearchCondition_ClearBodyOneOfCase(SearchCondition *message) {
  GPBDescriptor *descriptor = [SearchCondition descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SearchPeerTypeCondition

@implementation SearchPeerTypeCondition

@dynamic peerType;

typedef struct SearchPeerTypeCondition__storage_ {
  uint32_t _has_storage_[1];
  SearchPeerType peerType;
} SearchPeerTypeCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerType",
        .dataTypeSpecific.enumDescFunc = SearchPeerType_EnumDescriptor,
        .number = SearchPeerTypeCondition_FieldNumber_PeerType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerTypeCondition__storage_, peerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerTypeCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerTypeCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SearchPeerTypeCondition_PeerType_RawValue(SearchPeerTypeCondition *message) {
  GPBDescriptor *descriptor = [SearchPeerTypeCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerTypeCondition_FieldNumber_PeerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSearchPeerTypeCondition_PeerType_RawValue(SearchPeerTypeCondition *message, int32_t value) {
  GPBDescriptor *descriptor = [SearchPeerTypeCondition descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerTypeCondition_FieldNumber_PeerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SearchPieceText

@implementation SearchPieceText

@dynamic query;

typedef struct SearchPieceText__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SearchPieceText__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchPieceText_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPieceText__storage_, query),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPieceText class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPieceText__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchAndCondition

@implementation SearchAndCondition

@dynamic andQueryArray, andQueryArray_Count;

typedef struct SearchAndCondition__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *andQueryArray;
} SearchAndCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "andQueryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = SearchAndCondition_FieldNumber_AndQueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchAndCondition__storage_, andQueryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchAndCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchAndCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchOrCondition

@implementation SearchOrCondition

@dynamic orQueryArray, orQueryArray_Count;

typedef struct SearchOrCondition__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *orQueryArray;
} SearchOrCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orQueryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = SearchOrCondition_FieldNumber_OrQueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchOrCondition__storage_, orQueryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchOrCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchOrCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPeerCondition

@implementation SearchPeerCondition

@dynamic hasPeer, peer;

typedef struct SearchPeerCondition__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} SearchPeerCondition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = SearchPeerCondition_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerCondition__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerCondition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerCondition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchPeerContentType

@implementation SearchPeerContentType

@dynamic contentType;

typedef struct SearchPeerContentType__storage_ {
  uint32_t _has_storage_[1];
  SearchContentType contentType;
} SearchPeerContentType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentType",
        .dataTypeSpecific.enumDescFunc = SearchContentType_EnumDescriptor,
        .number = SearchPeerContentType_FieldNumber_ContentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchPeerContentType__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchPeerContentType class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchPeerContentType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SearchPeerContentType_ContentType_RawValue(SearchPeerContentType *message) {
  GPBDescriptor *descriptor = [SearchPeerContentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerContentType_FieldNumber_ContentType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSearchPeerContentType_ContentType_RawValue(SearchPeerContentType *message, int32_t value) {
  GPBDescriptor *descriptor = [SearchPeerContentType descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SearchPeerContentType_FieldNumber_ContentType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SearchSenderIdConfition

@implementation SearchSenderIdConfition

@dynamic senderId;

typedef struct SearchSenderIdConfition__storage_ {
  uint32_t _has_storage_[1];
  int32_t senderId;
} SearchSenderIdConfition__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = SearchSenderIdConfition_FieldNumber_SenderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchSenderIdConfition__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchSenderIdConfition class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchSenderIdConfition__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerSearchResult

@implementation PeerSearchResult

@dynamic hasPeer, peer;
@dynamic title;
@dynamic hasShortname, shortname;
@dynamic hasDescription_p, description_p;
@dynamic hasMembersCount, membersCount;
@dynamic dateCreated;
@dynamic hasCreator, creator;
@dynamic hasIsPublic, isPublic;
@dynamic hasIsJoined, isJoined;

typedef struct PeerSearchResult__storage_ {
  uint32_t _has_storage_[1];
  Peer *peer;
  NSString *title;
  GPBStringValue *description_p;
  GPBInt32Value *membersCount;
  GPBInt32Value *creator;
  GPBBoolValue *isPublic;
  GPBBoolValue *isJoined;
  GPBStringValue *shortname;
  int64_t dateCreated;
} PeerSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = PeerSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = PeerSearchResult_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = PeerSearchResult_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "membersCount",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = PeerSearchResult_FieldNumber_MembersCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, membersCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dateCreated",
        .dataTypeSpecific.clazz = Nil,
        .number = PeerSearchResult_FieldNumber_DateCreated,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, dateCreated),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creator",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBInt32Value),
        .number = PeerSearchResult_FieldNumber_Creator,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, creator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isPublic",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSearchResult_FieldNumber_IsPublic,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, isPublic),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isJoined",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBoolValue),
        .number = PeerSearchResult_FieldNumber_IsJoined,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, isJoined),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortname",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = PeerSearchResult_FieldNumber_Shortname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerSearchResult__storage_, shortname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestPeerSearch

@implementation RequestPeerSearch

@dynamic queryArray, queryArray_Count;
@dynamic optimizationsArray, optimizationsArray_Count;

typedef struct RequestPeerSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *queryArray;
  GPBEnumArray *optimizationsArray;
} RequestPeerSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "queryArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = RequestPeerSearch_FieldNumber_QueryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestPeerSearch__storage_, queryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "optimizationsArray",
        .dataTypeSpecific.enumDescFunc = UpdateOptimization_EnumDescriptor,
        .number = RequestPeerSearch_FieldNumber_OptimizationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestPeerSearch__storage_, optimizationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestPeerSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestPeerSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponsePeerSearch

@implementation ResponsePeerSearch

@dynamic usersArray, usersArray_Count;
@dynamic groupsArray, groupsArray_Count;
@dynamic searchResultsArray, searchResultsArray_Count;
@dynamic userPeersArray, userPeersArray_Count;
@dynamic groupPeersArray, groupPeersArray_Count;

typedef struct ResponsePeerSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *searchResultsArray;
  NSMutableArray *usersArray;
  NSMutableArray *groupsArray;
  NSMutableArray *userPeersArray;
  NSMutableArray *groupPeersArray;
} ResponsePeerSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(PeerSearchResult),
        .number = ResponsePeerSearch_FieldNumber_SearchResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, searchResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(User),
        .number = ResponsePeerSearch_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Group),
        .number = ResponsePeerSearch_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponsePeerSearch_FieldNumber_UserPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, userPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponsePeerSearch_FieldNumber_GroupPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponsePeerSearch__storage_, groupPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponsePeerSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponsePeerSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestResolvePeer

@implementation RequestResolvePeer

@dynamic shortname;

typedef struct RequestResolvePeer__storage_ {
  uint32_t _has_storage_[1];
  NSString *shortname;
} RequestResolvePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "shortname",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestResolvePeer_FieldNumber_Shortname,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestResolvePeer__storage_, shortname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestResolvePeer class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestResolvePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseResolvePeer

@implementation ResponseResolvePeer

@dynamic hasPeer, peer;

typedef struct ResponseResolvePeer__storage_ {
  uint32_t _has_storage_[1];
  OutPeer *peer;
} ResponseResolvePeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ResponseResolvePeer_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseResolvePeer__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseResolvePeer class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseResolvePeer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageSearchResult

@implementation MessageSearchResult

@dynamic hasPeer, peer;
@dynamic rid;
@dynamic date;
@dynamic senderId;
@dynamic hasContent, content;
@dynamic hasMid, mid;

typedef struct MessageSearchResult__storage_ {
  uint32_t _has_storage_[1];
  int32_t senderId;
  Peer *peer;
  MessageContent *content;
  UUIDValue *mid;
  int64_t rid;
  int64_t date;
} MessageSearchResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peer",
        .dataTypeSpecific.clazz = GPBObjCClass(Peer),
        .number = MessageSearchResult_FieldNumber_Peer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, peer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rid",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageSearchResult_FieldNumber_Rid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, rid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "date",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageSearchResult_FieldNumber_Date,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, date),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "senderId",
        .dataTypeSpecific.clazz = Nil,
        .number = MessageSearchResult_FieldNumber_SenderId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, senderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageContent),
        .number = MessageSearchResult_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.clazz = GPBObjCClass(UUIDValue),
        .number = MessageSearchResult_FieldNumber_Mid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MessageSearchResult__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageSearchResult class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageSearchResult__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageSearchItem

@implementation MessageSearchItem

@dynamic hasResult, result;

typedef struct MessageSearchItem__storage_ {
  uint32_t _has_storage_[1];
  MessageSearchResult *result;
} MessageSearchItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageSearchResult),
        .number = MessageSearchItem_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageSearchItem__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageSearchItem class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageSearchItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseMessageSearchResponse

@implementation ResponseMessageSearchResponse

@dynamic searchResultsArray, searchResultsArray_Count;
@dynamic hasLoadMoreState, loadMoreState;
@dynamic userOutPeersArray, userOutPeersArray_Count;
@dynamic groupOutPeersArray, groupOutPeersArray_Count;
@dynamic totalCount;

typedef struct ResponseMessageSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *searchResultsArray;
  GPBBytesValue *loadMoreState;
  NSMutableArray *userOutPeersArray;
  NSMutableArray *groupOutPeersArray;
  int64_t totalCount;
} ResponseMessageSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchResultsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MessageSearchItem),
        .number = ResponseMessageSearchResponse_FieldNumber_SearchResultsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, searchResultsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBBytesValue),
        .number = ResponseMessageSearchResponse_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, loadMoreState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userOutPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserOutPeer),
        .number = ResponseMessageSearchResponse_FieldNumber_UserOutPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, userOutPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupOutPeersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GroupOutPeer),
        .number = ResponseMessageSearchResponse_FieldNumber_GroupOutPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, groupOutPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseMessageSearchResponse_FieldNumber_TotalCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseMessageSearchResponse__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseMessageSearchResponse class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseMessageSearchResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSearch

@implementation RequestMessageSearch

@dynamic hasQuery, query;
@dynamic optimizationsArray, optimizationsArray_Count;

typedef struct RequestMessageSearch__storage_ {
  uint32_t _has_storage_[1];
  SearchCondition *query;
  GPBEnumArray *optimizationsArray;
} RequestMessageSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchCondition),
        .number = RequestMessageSearch_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSearch__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "optimizationsArray",
        .dataTypeSpecific.enumDescFunc = UpdateOptimization_EnumDescriptor,
        .number = RequestMessageSearch_FieldNumber_OptimizationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestMessageSearch__storage_, optimizationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestMessageSearchMore

@implementation RequestMessageSearchMore

@dynamic loadMoreState;
@dynamic optimizationsArray, optimizationsArray_Count;

typedef struct RequestMessageSearchMore__storage_ {
  uint32_t _has_storage_[1];
  NSData *loadMoreState;
  GPBEnumArray *optimizationsArray;
} RequestMessageSearchMore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestMessageSearchMore_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestMessageSearchMore__storage_, loadMoreState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "optimizationsArray",
        .dataTypeSpecific.enumDescFunc = UpdateOptimization_EnumDescriptor,
        .number = RequestMessageSearchMore_FieldNumber_OptimizationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestMessageSearchMore__storage_, optimizationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestMessageSearchMore class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestMessageSearchMore__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSimpleSearch

@implementation RequestSimpleSearch

@dynamic criteriaArray, criteriaArray_Count;
@dynamic optimizationsArray, optimizationsArray_Count;

typedef struct RequestSimpleSearch__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *criteriaArray;
  GPBEnumArray *optimizationsArray;
} RequestSimpleSearch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "criteriaArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SimpleSearchCondition),
        .number = RequestSimpleSearch_FieldNumber_CriteriaArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSimpleSearch__storage_, criteriaArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "optimizationsArray",
        .dataTypeSpecific.enumDescFunc = UpdateOptimization_EnumDescriptor,
        .number = RequestSimpleSearch_FieldNumber_OptimizationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSimpleSearch__storage_, optimizationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSimpleSearch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSimpleSearch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSimpleSearchMore

@implementation RequestSimpleSearchMore

@dynamic loadMoreState;
@dynamic optimizationsArray, optimizationsArray_Count;

typedef struct RequestSimpleSearchMore__storage_ {
  uint32_t _has_storage_[1];
  NSData *loadMoreState;
  GPBEnumArray *optimizationsArray;
} RequestSimpleSearchMore__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "loadMoreState",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestSimpleSearchMore_FieldNumber_LoadMoreState,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestSimpleSearchMore__storage_, loadMoreState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "optimizationsArray",
        .dataTypeSpecific.enumDescFunc = UpdateOptimization_EnumDescriptor,
        .number = RequestSimpleSearchMore_FieldNumber_OptimizationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestSimpleSearchMore__storage_, optimizationsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSimpleSearchMore class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestSimpleSearchMore__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestFieldAutocomplete

@implementation RequestFieldAutocomplete

@dynamic fieldName;
@dynamic fieldValue;

typedef struct RequestFieldAutocomplete__storage_ {
  uint32_t _has_storage_[1];
  NSString *fieldName;
  NSString *fieldValue;
} RequestFieldAutocomplete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fieldName",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFieldAutocomplete_FieldNumber_FieldName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestFieldAutocomplete__storage_, fieldName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldValue",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestFieldAutocomplete_FieldNumber_FieldValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestFieldAutocomplete__storage_, fieldValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestFieldAutocomplete class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestFieldAutocomplete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseFieldAutocomplete

@implementation ResponseFieldAutocomplete

@dynamic fieldName;
@dynamic fieldValueArray, fieldValueArray_Count;

typedef struct ResponseFieldAutocomplete__storage_ {
  uint32_t _has_storage_[1];
  NSString *fieldName;
  NSMutableArray *fieldValueArray;
} ResponseFieldAutocomplete__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fieldName",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseFieldAutocomplete_FieldNumber_FieldName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseFieldAutocomplete__storage_, fieldName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldValueArray",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseFieldAutocomplete_FieldNumber_FieldValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseFieldAutocomplete__storage_, fieldValueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseFieldAutocomplete class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseFieldAutocomplete__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadUserSearchByPredicatesResults

@implementation RequestLoadUserSearchByPredicatesResults

@dynamic predicatesArray, predicatesArray_Count;
@dynamic groupId;
@dynamic hasQuery, query;
@dynamic limit;
@dynamic requiredFieldsArray, requiredFieldsArray_Count;

typedef struct RequestLoadUserSearchByPredicatesResults__storage_ {
  uint32_t _has_storage_[1];
  int32_t groupId;
  int32_t limit;
  NSMutableArray *predicatesArray;
  GPBStringValue *query;
  NSMutableArray *requiredFieldsArray;
} RequestLoadUserSearchByPredicatesResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "query",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_Query,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "limit",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, limit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "requiredFieldsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesResults_FieldNumber_RequiredFieldsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesResults__storage_, requiredFieldsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadUserSearchByPredicatesResults class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadUserSearchByPredicatesResults__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserMatch

@implementation UserMatch

@dynamic userId;
@dynamic matchPredicates;

typedef struct UserMatch__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
} UserMatch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.clazz = Nil,
        .number = UserMatch_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserMatch__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "matchPredicates",
        .dataTypeSpecific.clazz = Nil,
        .number = UserMatch_FieldNumber_MatchPredicates,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserMatch class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserMatch__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadUserSearchByPredicatesResults

@implementation ResponseLoadUserSearchByPredicatesResults

@dynamic usersArray, usersArray_Count;
@dynamic resultCount;

typedef struct ResponseLoadUserSearchByPredicatesResults__storage_ {
  uint32_t _has_storage_[1];
  int32_t resultCount;
  NSMutableArray *usersArray;
} ResponseLoadUserSearchByPredicatesResults__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UserMatch),
        .number = ResponseLoadUserSearchByPredicatesResults_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesResults__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadUserSearchByPredicatesResults_FieldNumber_ResultCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesResults__storage_, resultCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadUserSearchByPredicatesResults class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadUserSearchByPredicatesResults__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestLoadUserSearchByPredicatesCount

@implementation RequestLoadUserSearchByPredicatesCount

@dynamic predicatesArray, predicatesArray_Count;
@dynamic groupId;

typedef struct RequestLoadUserSearchByPredicatesCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t groupId;
  NSMutableArray *predicatesArray;
} RequestLoadUserSearchByPredicatesCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "predicatesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SearchPredicate),
        .number = RequestLoadUserSearchByPredicatesCount_FieldNumber_PredicatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesCount__storage_, predicatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.clazz = Nil,
        .number = RequestLoadUserSearchByPredicatesCount_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestLoadUserSearchByPredicatesCount__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestLoadUserSearchByPredicatesCount class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestLoadUserSearchByPredicatesCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoadUserSearchByPredicatesCount

@implementation ResponseLoadUserSearchByPredicatesCount

@dynamic resultCount;

typedef struct ResponseLoadUserSearchByPredicatesCount__storage_ {
  uint32_t _has_storage_[1];
  int32_t resultCount;
} ResponseLoadUserSearchByPredicatesCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resultCount",
        .dataTypeSpecific.clazz = Nil,
        .number = ResponseLoadUserSearchByPredicatesCount_FieldNumber_ResultCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseLoadUserSearchByPredicatesCount__storage_, resultCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoadUserSearchByPredicatesCount class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseLoadUserSearchByPredicatesCount__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestGetRecommendations

@implementation RequestGetRecommendations


typedef struct RequestGetRecommendations__storage_ {
  uint32_t _has_storage_[1];
} RequestGetRecommendations__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestGetRecommendations class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestGetRecommendations__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseGetRecommendations

@implementation ResponseGetRecommendations

@dynamic peersArray, peersArray_Count;

typedef struct ResponseGetRecommendations__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} ResponseGetRecommendations__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OutPeer),
        .number = ResponseGetRecommendations_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResponseGetRecommendations__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseGetRecommendations class]
                                     rootClass:[SearchRoot class]
                                          file:SearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseGetRecommendations__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
